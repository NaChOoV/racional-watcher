import type { StockRange, User } from '../db/schema';
import type StockRepository from '../repository/stock.repository';
import type { Position } from '../types/racional.types';
import { InvalidCredentials, RacionalService } from './racional.service';

type UserStocksResult = {
    expiredUsers: User[];
    stockResults: {
        userId: number;
        stocks: Position[];
    }[];
    errors: {
        userId: number;
        error: Error;
    }[];
};

export type VariationResult = {
    userId: number;
    assetId: string;
    newValue: number;
    variation: number;
    variationType: Variation;
    newRanges: StockRange[];
};

export enum Variation {
    INCREASE = 'INCREASE',
    DECREASE = 'DECREASE',
}

class StockService {
    private readonly racionalService: RacionalService;
    private readonly stockRepository: StockRepository;

    constructor(racionalService: RacionalService, stockRepository: StockRepository) {
        this.racionalService = racionalService;
        this.stockRepository = stockRepository;
    }

    public async getUserStocks(users: User[]): Promise<UserStocksResult> {
        const stocksPromises = users.map((user) =>
            this.racionalService.getStocks(user.token as string)
        );

        const promiseResult = await Promise.allSettled(stocksPromises);

        const expiredUsers: User[] = [];
        const stockResults: { userId: number; stocks: Position[] }[] = [];
        const errors: { userId: number; error: Error }[] = [];

        promiseResult.forEach((result, index) => {
            const user = users[index] as User;

            if (result.status === 'fulfilled') {
                stockResults.push({ userId: user.id, stocks: result.value });
            } else if (result.status === 'rejected') {
                if (result.reason instanceof InvalidCredentials) {
                    expiredUsers.push(user);
                    return;
                }

                errors.push({ userId: user.id, error: result.reason });
            }
        });

        stockResults.forEach((result) => {
            result.stocks = result.stocks.filter((stock) => stock.amountUSD > 10);
        });

        return {
            expiredUsers,
            stockResults,
            errors,
        };
    }

    public syncUserStocks(userId: number, assetIds: string[]): Promise<void> {
        return this.stockRepository.syncStocks(userId, assetIds);
    }

    public async updateStockRanges(variations: VariationResult[]): Promise<void> {
        return this.stockRepository.updateStockRanges(variations);
    }

    public async compareStocksByTotalRevenue(
        userId: number,
        stocks: Position[]
    ): Promise<VariationResult[]> {
        const stockRanges = await this.stockRepository.getStocksByUserIds([userId]);

        const rangesUpdate: VariationResult[] = [];
        stockRanges.forEach(({ assetId, ranges }) => {
            const stock = stocks.find((s) => s.assetId === assetId) as Position;
            if (!stock) return;

            const result = StockService.getVariation(stock, ranges);

            if (result) {
                const variationType = StockService.getVariationTypeByStockRange(ranges, result);

                if (variationType) {
                    rangesUpdate.push({
                        userId,
                        assetId: stock.assetId,
                        newValue: stock.unrealizedPL,
                        variation: stock.unrealizedPLPercent,
                        variationType,
                        newRanges: result,
                    });
                }
            }
        });

        return rangesUpdate;
    }

    /**
     * *GENERATED BY AI*
     *
     * Determines the new ranges configuration based on the current position's unrealized profit/loss percentage.
     * @param position - The current position with unrealized profit/loss percentage.
     * @param ranges - The existing stock ranges to evaluate against.
     * @returns An array of StockRange objects representing the new ranges configuration, or undefined if no change is needed.
     */
    static getVariation(position: Position, ranges: StockRange[]): StockRange[] | undefined {
        const currentValue = position.unrealizedPLPercent;

        // Sort ranges by value in descending order
        const sortedRanges = [...ranges].sort((a, b) => b.value - a.value);

        // Find ranges that are currently "in"
        const inRanges = sortedRanges.filter((range) => range.in);

        if (inRanges.length > 0) {
            const highestInValue = Math.max(...inRanges.map((r) => r.value));
            const lowestInValue = Math.min(...inRanges.map((r) => r.value));

            // If the value is between the current "in" range bounds, no change needed
            if (currentValue >= lowestInValue && currentValue <= highestInValue) {
                return undefined;
            }

            // Check if we should return undefined for values beyond existing "in" ranges
            // This applies when the value is beyond the outermost range AND there's already
            // an "in" range at that boundary
            const allRangeValues = sortedRanges.map((r) => r.value);
            const highestRangeValue = Math.max(...allRangeValues);
            const lowestRangeValue = Math.min(...allRangeValues);

            // For values beyond the outermost range: return undefined only if there's already
            // an "in" range at that exact boundary
            if (currentValue > highestRangeValue) {
                const highestRange = sortedRanges.find((r) => r.value === highestRangeValue);
                if (highestRange?.in) {
                    return undefined;
                }
            }
            if (currentValue < lowestRangeValue) {
                const lowestRange = sortedRanges.find((r) => r.value === lowestRangeValue);
                if (lowestRange?.in) {
                    return undefined;
                }
            }
        }

        // Create new ranges configuration
        const newRanges = sortedRanges.map((range) => ({
            value: range.value,
            in: false,
        }));

        // Determine which ranges should be "in" based on the current value
        if (currentValue > 0) {
            // For positive values
            let rangeFound = false;
            for (let i = 0; i < sortedRanges.length; i++) {
                const range = sortedRanges[i]!;
                if (currentValue >= range.value) {
                    // Value is >= this range
                    if (i === 0) {
                        // This is the highest range, mark all ranges from highest down to here
                        for (let j = 0; j <= i; j++) {
                            newRanges[j]!.in = true;
                        }
                    } else {
                        // Check if value is between this range and the next higher range
                        const higherRange = sortedRanges[i - 1]!;
                        if (currentValue < higherRange.value) {
                            // Value is between ranges, mark both this and the higher range
                            newRanges[i]!.in = true;
                            newRanges[i - 1]!.in = true;
                        } else {
                            // Value is >= higher range, mark all ranges from highest down to current
                            for (let j = 0; j <= i; j++) {
                                newRanges[j]!.in = true;
                            }
                        }
                    }
                    rangeFound = true;
                    break;
                }
            }
            // If value is above all ranges, mark only the highest range
            if (!rangeFound) {
                newRanges[0]!.in = true;
            }
        } else {
            // For negative values
            let rangeFound = false;
            for (let i = sortedRanges.length - 1; i >= 0; i--) {
                const range = sortedRanges[i]!;
                if (currentValue <= range.value) {
                    // Value is <= this range
                    if (i === sortedRanges.length - 1) {
                        // This is the lowest range, mark all ranges from this down to lowest
                        for (let j = i; j < sortedRanges.length; j++) {
                            newRanges[j]!.in = true;
                        }
                    } else {
                        // Check if value is between this range and the next lower range
                        const lowerRange = sortedRanges[i + 1]!;
                        if (currentValue > lowerRange.value) {
                            // Value is between ranges, mark both this and the lower range
                            newRanges[i]!.in = true;
                            newRanges[i + 1]!.in = true;
                        } else {
                            // Value is <= lower range, mark all ranges from current down to lowest
                            for (let j = i; j < sortedRanges.length; j++) {
                                newRanges[j]!.in = true;
                            }
                        }
                    }
                    rangeFound = true;
                    break;
                }
            }
            // If value is below all ranges, mark only the lowest range
            if (!rangeFound) {
                newRanges[newRanges.length - 1]!.in = true;
            }
        }

        return newRanges;
    }

    static getVariationTypeByStockRange(
        stockRange: StockRange[],
        newStockRange: StockRange[]
    ): Variation | undefined {
        // Find the active ranges (where in = true) in both old and new configurations
        const oldActiveRanges = stockRange.filter((range) => range.in);
        const newActiveRanges = newStockRange.filter((range) => range.in);

        // If no change in active ranges, return undefined
        if (
            oldActiveRanges.length === newActiveRanges.length &&
            oldActiveRanges.every((oldRange) =>
                newActiveRanges.some(
                    (newRange) => newRange.value === oldRange.value && newRange.in === oldRange.in
                )
            )
        ) {
            return undefined;
        }

        // Calculate the average value of active ranges for comparison
        const getAverageActiveValue = (ranges: StockRange[]): number => {
            if (ranges.length === 0) return 0;
            return ranges.reduce((sum, range) => sum + range.value, 0) / ranges.length;
        };

        const oldAverage = getAverageActiveValue(oldActiveRanges);
        const newAverage = getAverageActiveValue(newActiveRanges);

        // If new average is higher than old average, it's an increase
        if (newAverage > oldAverage) {
            return Variation.INCREASE;
        }

        // If new average is lower than old average, it's a decrease
        if (newAverage < oldAverage) {
            return Variation.DECREASE;
        }

        // If averages are equal, check if we moved towards more positive ranges
        const oldMaxValue =
            oldActiveRanges.length > 0 ? Math.max(...oldActiveRanges.map((r) => r.value)) : 0;
        const newMaxValue =
            newActiveRanges.length > 0 ? Math.max(...newActiveRanges.map((r) => r.value)) : 0;

        if (newMaxValue > oldMaxValue) {
            return Variation.INCREASE;
        }

        if (newMaxValue < oldMaxValue) {
            return Variation.DECREASE;
        }

        return undefined;
    }
}

export default StockService;
